#!/bin/bash
# cmdlog - View clawdbot commands from audit logs
# Location: ~/Projects/cmdlog/cmdlog

# Use system timezone (timedatectl is more reliable than /etc/timezone)
export TZ=$(timedatectl show --property=Timezone --value 2>/dev/null || cat /etc/timezone 2>/dev/null || echo "America/Bogota")

show_help() {
    cat << 'EOF'
cmdlog - View clawdbot command audit logs

USAGE:
    cmdlog [N]              Last N commands (default: 1000)
    cmdlog --all            All of today's commands (slow)
    cmdlog --today [N]      Today's commands (default: 1000)
    cmdlog --recent [N]     Last N commands (default: 200)
    cmdlog --search PATTERN Search for pattern
    cmdlog --live           Real-time watch
    cmdlog --raw [N]        Raw format

ALIASES: cmdlog-recent, cmdlog-today, cmdlog-search, cmdlog-live
EOF
}

# Process input with awk for speed
# Args: $1 = limit (0 = unlimited), stdin = raw audit lines
process_awk() {
    local limit="${1:-0}"
    
    awk -v limit="$limit" '
    function hex_decode(str) {
        result = ""
        for (i=1; i<=length(str); i+=2) {
            byte = substr(str, i, 2)
            result = result sprintf("%c", strtonum("0x" byte))
        }
        return result
    }
    
    BEGIN { count=0; last_ts=""; proctitle_cmd="" }
    
    # Capture PROCTITLE for bash commands with -c (shows the actual command run)
    /type=PROCTITLE/ {
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            last_ts = strftime("%m/%d %H:%M", m[1])
        }
        # Extract proctitle hex and decode
        if (match($0, /proctitle=([0-9a-fA-F]+)/, m)) {
            hex = m[1]
            proc = ""
            for (i=1; i<=length(hex); i+=2) {
                byte = substr(hex, i, 2)
                char = sprintf("%c", strtonum("0x" byte))
                proc = proc char
            }
            # If it is bash -c, extract the command
            if (proc ~ /^bash -c / || proc ~ /^sh -c /) {
                sub(/^bash -c /, "", proc)
                sub(/^sh -c /, "", proc)
                gsub(/[[:cntrl:]]/, "", proc)
                if (proc != "" && proc !~ /^#/) {
                    proctitle_cmd = proc
                }
            }
        }
    }
    
    /type=EXECVE/ {
        # Timestamp
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            ts = strftime("%m/%d %H:%M", m[1])
        }
        
        # Command + args
        cmd = ""
        for (i=0; i<=5; i++) {
            pattern = "a" i "=\"([^\"]+)\""
            if (match($0, pattern, m)) {
                arg = m[1]
                if (arg ~ /^[0-9a-f]+$/ && length(arg) > 4) {
                    arg = hex_decode(arg)
                    if (arg !~ /[[:print:][:space:]]/) arg = ""
                }
                if (i == 0) gsub(/.*\//, "", arg)
                if (arg != "") cmd = (cmd == "" ? arg : cmd " " arg)
            }
        }
        
        # Check if we have a proctitle for bash/sh commands
        if ((cmd ~ /^bash / || cmd ~ /^sh /) && proctitle_cmd != "") {
            print last_ts " | [builtin] " proctitle_cmd
            proctitle_cmd = ""
            if (limit > 0 && ++count >= limit) exit
            next
        }
        
        # Filter temp file noise (e.g., cp /tmp/tmp.XXX /tmp/tmp.YYY)
        if (cmd ~ /\/tmp\/tmp\./) next
        
        if (cmd ~ /cmdlog/) next
        if (cmd == "bash" || cmd == "sh") next
        if (cmd ~ /^bash -[lc]$/) next
        if (cmd == "sh -c") next
        
        if (cmd != "") {
            print ts " | " cmd
            if (limit > 0 && ++count >= limit) exit
        }
    }'
}

# Read audit and process - include both EXECVE and PROCTITLE for bash builtins
cmd_main() {
    local n="${1:-1000}"
    echo "Recent commands (last $n):"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | tail -n "$((n*4))" | process_awk "$n" | tail -n "$n"
}

cmd_all() {
    echo "All of today's commands:"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | process_awk 0
}

cmd_recent() { cmd_main "${1:-200}"; }

cmd_search() {
    local pat="${1:-}"
    [ -z "$pat" ] && { echo "Usage: cmdlog --search PATTERN"; exit 1; }
    echo "Searching for: $pat"
    cmd_main 1000 | grep -i "$pat"
}

cmd_live() {
    local prev=$(mktemp); local curr=$(mktemp)
    trap "rm -f $prev $curr" EXIT
    
    echo "Watching for new commands... (Ctrl+C to stop)"
    echo "=============================================="
    
    # Get initial snapshot (last 50 entries)
    sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | tail -50 > "$prev"
    
    while true; do
        sleep 2
        
        # Get current snapshot
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
        grep -E "^type=(EXECVE|PROCTITLE)" | tail -50 > "$curr"
        
        # Show only new commands (in curr but not in prev)
        comm -23 <(sort "$curr") <(sort "$prev") | process_awk 0
        
        # Swap: prev becomes curr for next iteration (avoids cp/touch)
        mv "$curr" "$prev" 2>/dev/null
    done
}

cmd_raw() {
    local n="${1:-}"
    if [ -n "$n" ]; then
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep -E "^type=(EXECVE|PROCTITLE)" | tail -n "$n"
    else
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep -E "^type=(EXECVE|PROCTITLE)"
    fi
}

case "${1:-}" in
    --help|-h) show_help ;;
    --all) cmd_all ;;
    --recent) cmd_recent "$2" ;;
    --today) 
        if [ -n "$2" ]; then cmd_main "$2"; else cmd_main 1000; fi
        ;;
    --search) cmd_search "$2" ;;
    --grep) cmd_search "$2" ;;
    --live) cmd_live ;;
    --raw) cmd_raw "$2" ;;
    "") cmd_main 1000 ;;
    [0-9]*) cmd_main "$1" ;;
    *) echo "Unknown option: $1" >&2; exit 1 ;;
esac
