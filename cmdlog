#!/bin/bash
#
# cmdlog - Audit log viewer for clawdbot commands
# 
# This script reads from Linux auditd logs to display commands executed
# by the clawdbot user. It filters out internal/system noise and provides
# human-readable output.
#
# Requirements:
#   - auditd installed and running
#   - sudo access to read /var/log/audit/audit.log
#   - audit rule: -a always,exit -F arch=b64 -S execve -F uid=1001 -k clawdbot_exec
#
# Location: ~/Projects/cmdlog/cmdlog
#

# Default timezone for timestamps (use system timezone)
export TZ=$(cat /etc/timezone 2>/dev/null || echo "America/Bogota")

# Filter patterns - commands to exclude from output
# Only filter pure utility commands, not bash/sh which may contain user commands
FILTER_WORDS="grep|tail|head|awk|perl|sed|xxd|printf|date|cat|tee|seq|sort|comm|tr|uniq|wc|tac"
FILTER_WORDS="${FILTER_WORDS}|sudo|ip|locale-check|dirname|node|python3|env|jq|flock|ssh"

# Show help/usage
show_help() {
    cat << 'EOF'
cmdlog - View clawdbot command audit logs

USAGE:
    cmdlog [N]                  Show recent N commands (default: 1000)
    cmdlog --all                Show all of today's commands (may be slow)
    cmdlog --recent [N]         Last N commands (default: 200)
    cmdlog --today [N]          Today's commands, limited to N
    cmdlog --grep <pattern>     Search for commands matching pattern
    cmdlog --live               Real-time watch mode
    cmdlog --raw [N]            Raw audit format
    cmdlog --help               Show this help

ALIASES:
    cmdlog-recent  = cmdlog --recent 200
    cmdlog-today   = cmdlog --today
    cmdlog-grep    = cmdlog --grep
    cmdlog-live    = cmdlog --live

EXAMPLES:
    cmdlog                      # Last 1000 commands (fast)
    cmdlog 50                   # Just the last 50
    cmdlog --all                # All of today's commands (slow)
    cmdlog --grep "git commit"  # Find git push commands
    cmdlog --live               # Watch new commands in real-time

NOTES:
    - Default shows last 1000 commands for speed
    - Use --all to see everything (may take 30+ seconds)
    - Timestamps are in local timezone (Bogota/UTC-5)
    - Filtering removes internal system noise but keeps bash commands
EOF
}

# Extract and format command from audit log line
format_command() {
    local line="$1"
    local ts_epoch ts cmd a0 arg decoded
    
    ts_epoch=$(echo "$line" | grep -oP 'msg=audit\(\K[0-9]+(?=\.)')
    [ -z "$ts_epoch" ] && return 1
    
    ts=$(date -d "@$ts_epoch" "+%m/%d %H:%M" 2>/dev/null)
    [ -z "$ts" ] && return 1
    
    a0=$(echo "$line" | grep -oP 'a0="\K[^"]+' | head -1)
    [ -z "$a0" ] && return 1
    
    # Remove common path prefixes
    a0=${a0#/usr/bin/}
    a0=${a0#/bin/}
    a0=${a0#/usr/lib/git-core/}
    a0=${a0#/usr/lib/openssh/}
    
    cmd="$a0"
    
    # Add arguments a1-a5
    for i in 1 2 3 4 5; do
        arg=$(echo "$line" | grep -oP "a$i=\"\K[^\"]+" | head -1)
        [ -z "$arg" ] && continue
        
        # Decode hex-encoded arguments
        if [[ "$arg" =~ ^[0-9a-fA-F]+$ ]] && [ ${#arg} -gt 4 ] && [ $(( ${#arg} % 2 )) -eq 0 ]; then
            decoded=$(printf '%s' "$arg" | xxd -r -p 2>/dev/null | tr -d '\0\n')
            [ -n "$decoded" ] && [[ "$decoded" =~ ^[[:print:][:space:]]+$ ]] && arg="$decoded"
        fi
        
        cmd="$cmd $arg"
    done
    
    # Clean up whitespace
    cmd=$(echo "$cmd" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
    [ -z "$cmd" ] && return 1
    [ ${#cmd} -lt 2 ] && return 1
    
    echo "$ts | $cmd"
}

# Check if command should be filtered
should_filter() {
    local cmd="$1"
    local first_word="${cmd%% *}"
    
    # Check against filter list (utilities only, not bash/sh)
    if [[ "$first_word" =~ ^(${FILTER_WORDS})$ ]]; then
        return 0
    fi
    
    # Filter cmdlog self-references
    if [[ "$cmd" =~ cmdlog ]]; then
        return 0
    fi
    
    # Filter empty bash/sh commands but KEEP bash commands with actual content
    [ "$cmd" = "bash -lc" ] && return 0
    [ "$cmd" = "sh -c" ] && return 0
    [ "$cmd" = "bash -c" ] && return 0
    [ "$cmd" = "bash" ] && return 0
    [ "$cmd" = "sh" ] && return 0
    
    return 1
}

# Read audit entries with limit
read_audit() {
    local max_entries="${1:-1000}"
    
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | \
    tail -n "$max_entries"
}

# Process entries with formatting and filtering
process_entries() {
    while read -r line; do
        local formatted cmd_part
        
        formatted=$(format_command "$line")
        [ -z "$formatted" ] && continue
        
        cmd_part="${formatted#*| }"
        if should_filter "$cmd_part"; then
            continue
        fi
        
        echo "$formatted"
    done
}

# Get recent N commands
cmd_recent() {
    local limit="${1:-200}"
    
    echo "Last $limit clawdbot commands:"
    echo "=============================="
    
    read_audit "$((limit * 2))" | process_entries | tail -n "$limit"
}

# Get all commands (slow)
cmd_all() {
    echo "All of today's clawdbot commands:"
    echo "================================="
    
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | \
    process_entries
}

# Default: get last 1000 commands (fast)
cmd_default() {
    local limit="${1:-1000}"
    
    echo "Recent clawdbot commands (last $limit):"
    echo "========================================"
    
    read_audit "$((limit * 2))" | process_entries | tail -n "$limit"
}

# Search commands for pattern
cmd_grep() {
    local pattern="$1"
    local count=0
    local max_results=500
    
    if [ -z "$pattern" ]; then
        echo "Error: No search pattern provided" >&2
        echo "Usage: cmdlog --grep <pattern>" >&2
        return 1
    fi
    
    echo "Searching for: $pattern (max $max_results results)"
    echo "=================================================="
    
    # Search last 5000 entries
    read_audit 5000 | \
    while read -r line && [ $count -lt $max_results ]; do
        local formatted cmd_part
        
        formatted=$(format_command "$line")
        [ -z "$formatted" ] && continue
        
        cmd_part="${formatted#*| }"
        if should_filter "$cmd_part"; then
            continue
        fi
        
        # Case insensitive match
        if [[ "${cmd_part,,}" == *"${pattern,,}"* ]]; then
            echo "$formatted"
            ((count++))
        fi
    done
}

# Real-time live monitor
cmd_live() {
    local tmpfile new_entries line formatted cmd_part
    
    echo "Watching for new commands... (Ctrl+C to stop)"
    echo "=============================================="
    
    tmpfile=$(mktemp)
    trap "rm -f $tmpfile ${tmpfile}.new" EXIT
    
    sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
    grep "^type=EXECVE" > "$tmpfile" 2>/dev/null
    
    while true; do
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
        grep "^type=EXECVE" > "${tmpfile}.new" 2>/dev/null
        
        new_entries=$(comm -13 <(sort "$tmpfile") <(sort "${tmpfile}.new") 2>/dev/null)
        
        if [ -n "$new_entries" ]; then
            echo "$new_entries" | while read -r line; do
                formatted=$(format_command "$line")
                [ -z "$formatted" ] && continue
                
                cmd_part="${formatted#*| }"
                if should_filter "$cmd_part"; then
                    continue
                fi
                
                echo "$formatted"
            done
        fi
        
        mv "${tmpfile}.new" "$tmpfile" 2>/dev/null
        sleep 2
    done
}

# Raw audit output
cmd_raw() {
    local limit="${1:-}"
    
    if [ -n "$limit" ]; then
        echo "Raw audit log entries (last $limit):"
        echo "===================================="
        read_audit "$limit"
    else
        echo "Raw audit log entries (all of today):"
        echo "======================================"
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
        grep "^type=EXECVE"
    fi
}

# ============================================================================
# MAIN
# ============================================================================

case "$1" in
    --help|-h)
        show_help
        exit 0
        ;;
    --all)
        cmd_all
        ;;
    --recent)
        cmd_recent "$2"
        ;;
    --today)
        if [ -n "$2" ]; then
            cmd_recent "$2"
        else
            cmd_default 1000
        fi
        ;;
    --grep)
        cmd_grep "$2"
        ;;
    --live)
        cmd_live
        ;;
    --raw)
        cmd_raw "$2"
        ;;
    "")
        # Default: show last 1000 (fast)
        cmd_default 1000
        ;;
    [0-9]*)
        # Number argument: show that many recent commands
        cmd_default "$1"
        ;;
    *)
        echo "Unknown option: $1" >&2
        echo "Use 'cmdlog --help' for usage information" >&2
        exit 1
        ;;
esac
