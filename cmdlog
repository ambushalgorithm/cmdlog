#!/bin/bash
#
# cmdlog - Audit log viewer for clawdbot commands
# 
# This script reads from Linux auditd logs to display commands executed
# by the clawdbot user. It filters out internal/system noise and provides
# human-readable output.
#
# Requirements:
#   - auditd installed and running
#   - sudo access to read /var/log/audit/audit.log
#   - audit rule: -a always,exit -F arch=b64 -S execve -F uid=1001 -k clawdbot_exec
#
# Location: ~/Projects/cmdlog/cmdlog
#

# Default timezone for timestamps
export TZ=$(cat /etc/timezone 2>/dev/null || echo "America/Bogota")

# Filter - only pure utilities, NOT bash/sh
FILTER="grep|tail|head|awk|perl|sed|xxd|printf|date|cat|tee|seq|sort|comm|tr|uniq|wc|tac|sudo|ip|locale-check|dirname|node|python3|env|jq|flock|ssh"

# Show help
show_help() {
    cat << 'EOF'
cmdlog - View clawdbot command audit logs

USAGE:
    cmdlog [N]                  Show last N commands (default: 1000)
    cmdlog --all                Show all of today's commands
    cmdlog --recent [N]         Last N commands (default: 200)  
    cmdlog --grep <pattern>     Search for pattern in recent commands
    cmdlog --live               Real-time watch
    cmdlog --raw [N]            Raw audit format
    cmdlog --help               Show help

EXAMPLES:
    cmdlog                      # Last 1000 commands
    cmdlog 50                   # Last 50 only
    cmdlog --all | less         # Everything (slow, pipe to less)
    cmdlog --grep git           # Find git commands

NOTES:
    - Default is limited to 1000 for speed (reading 195k entries takes minutes)
    - Use --all to see everything (may take 30+ seconds)
    - bash and sh commands are now shown (previously filtered)
EOF
}

# Extract and format a command line from audit output
format_line() {
    local line="$1"
    local ts_epoch ts a0 arg cmd decoded
    
    # Get timestamp
    ts_epoch=$(echo "$line" | grep -oP 'msg=audit\(\K[0-9]+(?=\.)')
    [ -z "$ts_epoch" ] && return
    ts=$(date -d "@$ts_epoch" "+%m/%d %H:%M" 2>/dev/null)
    [ -z "$ts" ] && return
    
    # Get command (a0)
    a0=$(echo "$line" | grep -oP 'a0="\K[^"]+' | head -1)
    [ -z "$a0" ] && return
    
    # Clean path
    a0=${a0##*/}
    
    # Build full command with args
    cmd="$a0"
    for i in 1 2 3 4 5 6; do
        arg=$(echo "$line" | grep -oP "a$i=\"\K[^\"]+" | head -1)
        [ -z "$arg" ] && continue
        
        # Decode hex if needed
        if [[ "$arg" =~ ^[0-9a-f]+$ ]] && [ ${#arg} -gt 4 ]; then
            decoded=$(echo "$arg" | xxd -r -p 2>/dev/null | tr -d '\0')
            [ -n "$decoded" ] && arg="$decoded"
        fi
        
        cmd="$cmd $arg"
    done
    
    # Clean up
    cmd=$(echo "$cmd" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
    [ ${#cmd} -lt 2 ] && return
    
    # Filter check
    local first="${cmd%% *}"
    [[ "$first" =~ ^($FILTER)$ ]] && return
    [[ "$cmd" =~ cmdlog ]] && return
    
    # Filter empty shells
    [ "$cmd" = "bash" ] && return
    [ "$cmd" = "sh" ] && return
    [ "$cmd" = "bash -c" ] && return
    [ "$cmd" = "bash -lc" ] && return
    [ "$cmd" = "sh -c" ] && return
    
    echo "$ts | $cmd"
}

# Main command - show recent N entries
cmdlog_main() {
    local n="${1:-1000}"
    
    echo "Last $n clawdbot commands:"
    echo "=========================="
    
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | \
    tail -n "$((n * 2))" | \
    while read line; do
        format_line "$line"
    done | tail -n "$n"
}

# Show all (slow)
cmdlog_all() {
    echo "All of today's clawdbot commands:"
    echo "================================="
    
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | \
    while read line; do
        format_line "$line"
    done
}

# Show recent N (alias for main)
cmdlog_recent() {
    local n="${1:-200}"
    cmdlog_main "$n"
}

# Search
cmdlog_grep() {
    local pattern="${1:-}"
    [ -z "$pattern" ] && { echo "Usage: cmdlog --grep <pattern>"; exit 1; }
    
    echo "Searching last 2000 commands for: $pattern"
    echo "==========================================="
    
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | \
    tail -n 2000 | \
    while read line; do
        local formatted=$(format_line "$line")
        [ -z "$formatted" ] && continue
        [[ "${formatted,,}" == *"${pattern,,}"* ]] && echo "$formatted"
    done | head -100
}

# Live mode
cmdlog_live() {
    local tmpfile=$(mktemp)
    trap "rm -f $tmpfile" EXIT
    
    echo "Watching... (Ctrl+C to stop)"
    echo "============================"
    
    sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
    grep "^type=EXECVE" > "$tmpfile"
    
    while true; do
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
        grep "^type=EXECVE" | \
        comm -13 <(sort "$tmpfile") - 2>/dev/null | \
        while read line; do
            format_line "$line"
        done
        
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
        grep "^type=EXECVE" > "$tmpfile"
        sleep 2
    done
}

# Raw mode
cmdlog_raw() {
    local n="${1:-}"
    
    if [ -n "$n" ]; then
        echo "Raw entries (last $n):"
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
        grep "^type=EXECVE" | tail -n "$n"
    else
        echo "Raw entries (all):"
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
        grep "^type=EXECVE"
    fi
}

# ============================================================================
# MAIN
# ============================================================================

case "${1:-}" in
    --help|-h) show_help ;;
    --all) cmdlog_all ;;
    --recent) cmdlog_recent "$2" ;;
    --grep) cmdlog_grep "$2" ;;
    --live) cmdlog_live ;;
    --raw) cmdlog_raw "$2" ;;
    "") cmdlog_main 1000 ;;  # Default: 1000 entries
    [0-9]*) cmdlog_main "$1" ;;  # Number: use as limit
    *) echo "Unknown: $1"; exit 1 ;;
esac
