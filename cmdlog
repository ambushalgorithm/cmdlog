#!/bin/bash
# cmdlog - View clawdbot commands from audit logs
# Location: ~/Projects/cmdlog/cmdlog

export TZ=$(cat /etc/timezone 2>/dev/null || echo "America/Bogota")

show_help() {
    cat << 'EOF'
cmdlog - View clawdbot command audit logs

USAGE:
    cmdlog [N]              Last N commands (default: 1000)
    cmdlog --all            All of today's commands (slow)
    cmdlog --grep PATTERN   Search for pattern
    cmdlog --live           Real-time watch
    cmdlog --raw [N]        Raw format

ALIASES: cmdlog-recent, cmdlog-today, cmdlog-grep, cmdlog-live
EOF
}

# Common filter pattern - utilities to exclude
FILTER_RE='^(grep|tail|head|awk|sed|cat|tee|sort|date|sudo|ip|locale|xxd|printf|seq|comm|tr|uniq|tac|wc|python3|jq|env|ssh|flock)$'

# Process input with awk for speed
# Args: $1 = limit (0 = unlimited), stdin = raw audit lines
process_awk() {
    local limit="${1:-0}"
    
    awk -v limit="$limit" '
    function hex_decode(str) {
        result = ""
        for (i=1; i<=length(str); i+=2) {
            byte = substr(str, i, 2)
            result = result sprintf("%c", strtonum("0x" byte))
        }
        return result
    }
    
    BEGIN { count=0 }
    
    /type=EXECVE/ {
        # Timestamp
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            ts = strftime("%m/%d %H:%M", m[1])
        }
        
        # Command + args
        cmd = ""
        for (i=0; i<=5; i++) {
            pattern = "a" i "=\"([^\"]+)\""
            if (match($0, pattern, m)) {
                arg = m[1]
                # Hex decode if needed
                if (arg ~ /^[0-9a-f]+$/ && length(arg) > 4) {
                    arg = hex_decode(arg)
                    if (arg !~ /[[:print:][:space:]]/) arg = ""
                }
                # Strip path from a0 only
                if (i == 0) {
                    gsub(/.*\//, "", arg)
                }
                if (arg != "") {
                    cmd = (cmd == "" ? arg : cmd " " arg)
                }
            }
        }
        
        # Filter
        first = cmd
        sub(/ .*/, "", first)
        if (first ~ /^('$(echo $FILTER_RE | sed 's/|/|/g')')$/) next
        if (cmd ~ /cmdlog/) next
        if (cmd == "bash" || cmd == "sh") next
        if (cmd ~ /^bash -[lc]$/) next
        if (cmd == "sh -c") next
        
        # Output
        if (cmd != "") {
            print ts " | " cmd
            if (limit > 0 && ++count >= limit) exit
        }
    }'
}

# Read audit and process
cmd_main() {
    local n="${1:-1000}"
    echo "Recent commands (last $n):"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | tail -n "$((n*2))" | process_awk "$n" | tail -n "$n"
}

cmd_all() {
    echo "All of today's commands:"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep "^type=EXECVE" | process_awk 0
}

cmd_recent() { cmd_main "${1:-200}"; }

cmd_grep() {
    local pat="${1:-}"
    [ -z "$pat" ] && { echo "Usage: cmdlog --grep PATTERN"; exit 1; }
    echo "Searching for: $pat"
    cmd_main 1000 | grep -i "$pat"
}

cmd_live() {
    local tmp=$(mktemp); trap "rm -f $tmp" EXIT
    echo "Watching... (Ctrl+C to stop)"
    sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | grep "^type=EXECVE" > "$tmp"
    while true; do
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | grep "^type=EXECVE" | \
        comm -13 <(sort "$tmp") - | process_awk 0
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | grep "^type=EXECVE" > "$tmp"
        sleep 2
    done
}

cmd_raw() {
    local n="${1:-}"
    if [ -n "$n" ]; then
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep "^type=EXECVE" | tail -n "$n"
    else
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep "^type=EXECVE"
    fi
}

case "${1:-}" in
    --help|-h) show_help ;;
    --all) cmd_all ;;
    --recent) cmd_recent "$2" ;;
    --grep) cmd_grep "$2" ;;
    --live) cmd_live ;;
    --raw) cmd_raw "$2" ;;
    "") cmd_main 1000 ;;
    [0-9]*) cmd_main "$1" ;;
    *) echo "Unknown option: $1" >&2; exit 1 ;;
esac
