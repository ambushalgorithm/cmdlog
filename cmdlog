#!/bin/bash
# cmdlog - View clawdbot commands from audit logs
# Location: ~/Projects/cmdlog/cmdlog

export TZ=$(timedatectl show --property=Timezone --value 2>/dev/null || cat /etc/timezone 2>/dev/null || echo "America/Bogota")

show_help() {
    cat << 'EOF'
cmdlog - View clawdbot command audit logs

USAGE:
    cmdlog [N]              Last N commands (default: 1000)
    cmdlog --all            All of today's commands (slow)
    cmdlog --today [N]      Today's commands (default: 1000)
    cmdlog --recent [N]     Last N commands (default: 200)
    cmdlog --search PATTERN Search for pattern
    cmdlog --live           Real-time watch
    cmdlog --raw [N]        Raw format

ALIASES: cmdlog-recent, cmdlog-today, cmdlog-search, cmdlog-live
EOF
}

# Common filter rules - used by both regular and live mode
# Returns 1 if command should be filtered (skip), 0 if keep
filter_rules() {
    local cmd="$1"
    local first="${cmd%% *}"
    
    # List of exact matches for first word
    case "$first" in
        grep|tail|head|awk|sed|cat|tee|sort|date|sudo|ip|locale|xxd|printf|seq|comm|tr|uniq|tac|wc|python3|jq|env|ssh|flock|sleep|mktemp) return 1 ;;
    esac
    
    # Pattern matches
    [[ "$cmd" =~ /tmp/tmp\. ]] && return 1
    [[ "$cmd" =~ ^grep\ -E\ \^type= ]] && return 1
    [[ "$cmd" =~ ^sudo\ ausearch\ -k\ clawdbot_exec ]] && return 1
    [[ "$cmd" =~ ^comm\ -23 ]] && return 1
    [[ "$cmd" =~ ^sleep\ [0-9] ]] && return 1
    [[ "$cmd" =~ ^awk\ -v\ limit= ]] && return 1
    [[ "$cmd" =~ ^tail\ - ]] && return 1
    [[ "$cmd" =~ ^timedatectl\ show ]] && return 1
    [[ "$cmd" =~ ^sh\ -c\ ip\ neigh\ show ]] && return 1
    [[ "$cmd" =~ ^ip\ neigh\ show$ ]] && return 1
    [[ "$cmd" =~ ^ip\ link\ show$ ]] && return 1
    [[ "$cmd" =~ ^wc\ -l$ ]] && return 1
    [[ "$cmd" =~ ^head\ -[23]$ ]] && return 1
    [[ "$cmd" =~ cmdlog ]] && return 1
    
    return 0
}

# Process input with awk for speed
# Args: $1 = limit (0 = unlimited), stdin = raw audit lines
process_awk() {
    local limit="${1:-0}"
    
    awk -v limit="$limit" '
    function hex_decode(str) {
        result = ""
        for (i=1; i<=length(str); i+=2) {
            byte = substr(str, i, 2)
            result = result sprintf("%c", strtonum("0x" byte))
        }
        return result
    }
    
    BEGIN { count=0; last_ts=""; proctitle_cmd="" }
    
    # Capture PROCTITLE for bash commands with -c
    /type=PROCTITLE/ {
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            last_ts = strftime("%m/%d %H:%M", m[1])
        }
        if (match($0, /proctitle=([0-9a-fA-F]+)/, m)) {
            hex = m[1]
            proc = ""
            for (i=1; i<=length(hex); i+=2) {
                byte = substr(hex, i, 2)
                char = sprintf("%c", strtonum("0x" byte))
                proc = proc char
            }
            if (proc ~ /^bash -c / || proc ~ /^sh -c /) {
                sub(/^bash -c /, "", proc)
                sub(/^sh -c /, "", proc)
                gsub(/[[:cntrl:]]/, "", proc)
                if (proc != "" && proc !~ /^#/) {
                    proctitle_cmd = proc
                }
            }
        }
    }
    
    /type=EXECVE/ {
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            ts = strftime("%m/%d %H:%M", m[1])
        }
        
        cmd = ""
        for (i=0; i<=5; i++) {
            arg = ""
            pattern_quoted = "a" i "=\"([^\"]+)\""
            pattern_unquoted = "a" i "=([0-9a-fA-F]+)"
            
            if (match($0, pattern_quoted, m)) {
                arg = m[1]
            } else if (match($0, pattern_unquoted, m)) {
                arg = m[1]
            }
            
            if (arg != "") {
                if (arg ~ /^[0-9a-fA-F]+$/ && length(arg) > 4) {
                    arg = hex_decode(arg)
                    if (arg !~ /^[[:print:][:space:]]+$/) arg = ""
                }
                if (i == 0) gsub(/.*\//, "", arg)
                if (arg != "") cmd = (cmd == "" ? arg : cmd " " arg)
            }
        }
        
        # Show PROCTILE decoded builtin
        if ((cmd ~ /^bash / || cmd ~ /^sh /) && proctitle_cmd != "") {
            print last_ts " | [builtin] " proctitle_cmd
            proctitle_cmd = ""
            if (limit > 0 && ++count >= limit) exit
        }
        
        # Filter rules
        first = cmd; sub(/ .*/, "", first)
        if (first ~ /^(grep|tail|head|awk|sed|cat|tee|sort|date|sudo|ip|locale|timedatectl|xxd|printf|seq|comm|tr|uniq|tac|wc|python3|jq|env|ssh|flock|sleep|mktemp)$/) next
        if (cmd ~ /\/tmp\/tmp\./) next
        if (cmd ~ /cmdlog/) next
        
        if (cmd != "") {
            print ts " | " cmd
            if (limit > 0 && ++count >= limit) exit
        }
    }'
}

# Read and process N lines
cmd_main() {
    local n="${1:-1000}"
    echo "Recent commands (last $n):"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | tail -n "$((n*4))" | process_awk "$n" | tail -n "$n"
}

cmd_all() {
    echo "All of today's commands:"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | process_awk 0
}

cmd_recent() { cmd_main "${1:-200}"; }

cmd_search() {
    local pat="${1:-}"
    [ -z "$pat" ] && { echo "Usage: cmdlog --search PATTERN"; exit 1; }
    echo "Searching for: $pat"
    cmd_main 1000 | grep -i "$pat"
}

cmd_live() {
    local prev=$(mktemp); local curr=$(mktemp)
    trap "rm -f $prev $curr" EXIT
    
    echo "Watching for new commands... (Ctrl+C to stop)"
    echo "=============================================="
    
    # Initialize prev with current state
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | process_awk > "$prev" 2>/dev/null
    
    while true; do
        sleep 2
        
        # Get new state
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
        grep -E "^type=(EXECVE|PROCTITLE)" | process_awk > "$curr" 2>/dev/null
        
        # Print lines in curr that aren't in prev - using comm
        # Only lines unique to curr (new commands)
        comm -13 <(sort "$prev" 2>/dev/null) <(sort "$curr" 2>/dev/null) 2>/dev/null
        
        # Update prev
        mv "$curr" "$prev" 2>/dev/null || true
    done
}

cmd_raw() {
    local n="${1:-}"
    if [ -n "$n" ]; then
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep -E "^type=(EXECVE|PROCTITLE)" | tail -n "$n"
    else
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep -E "^type=(EXECVE|PROCTITLE)"
    fi
}

case "${1:-}" in
    --help|-h) show_help ;;
    --all) cmd_all ;;
    --recent) cmd_recent "$2" ;;
    --today) 
        if [ -n "$2" ]; then cmd_main "$2"; else cmd_main 1000; fi
        ;;
    --search) cmd_search "$2" ;;
    --grep) cmd_search "$2" ;;
    --live) cmd_live ;;
    --raw) cmd_raw "$2" ;;
    "") cmd_main 1000 ;;
    [0-9]*) cmd_main "$1" ;;
    *) echo "Unknown option: $1" >&2; exit 1 ;;
esac
