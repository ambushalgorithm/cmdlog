#!/bin/bash
# openclaw-cmdlog - View OpenClaw agent commands from audit logs
# Config file: filters.conf in same directory as this script

export TZ=$(timedatectl show --property=Timezone --value 2>/dev/null || cat /etc/timezone 2>/dev/null || echo "America/Bogota")

# Get script directory for finding filters.conf
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load filters from config files (repo + user)
# Loads filters.conf from script directory first, then ~/.openclaw/.config/cmdlog.filters.conf
# Both files are merged - patterns from both are applied
load_user_filters() {
    local repo_config="${SCRIPT_DIR}/filters.conf"
    local user_config="${HOME}/.openclaw/.config/cmdlog.filters.conf"

    # Load repo filters (base/defaults)
    if [ -f "$repo_config" ]; then
        grep -v '^#' "$repo_config" 2>/dev/null | grep -v '^$'
    fi

    # Load user filters (additional)
    if [ -f "$user_config" ]; then
        grep -v '^#' "$user_config" 2>/dev/null | grep -v '^$'
    fi
}

show_help() {
    cat << 'EOF'
openclaw-cmdlog - View OpenClaw agent command audit logs

USAGE:
    openclaw-cmdlog [N]              Last N commands (default: 1000)
    openclaw-cmdlog --all            All of today's commands (slow)
    openclaw-cmdlog --today [N]      Today's commands (default: 1000)
    openclaw-cmdlog --recent [N]     Last N commands (default: 200)
    openclaw-cmdlog --search PATTERN Search for pattern
    openclaw-cmdlog --live           Real-time watch
    openclaw-cmdlog --raw [N]        Raw format
    openclaw-cmdlog --show-filters   Display active filters

ALIASES: openclaw-cmdlog-recent, openclaw-cmdlog-today, openclaw-cmdlog-search,
         openclaw-cmdlog-live, openclaw-cmdlog-raw

CONFIG:
    Two filter config files (both optional, patterns merged):
    1. Repo: filters.conf in same directory as this script (base/defaults)
    2. User: ~/.openclaw/.config/cmdlog.filters.conf (personal filters)
    One pattern per line (regex allowed). Lines starting with # are ignored.
EOF
}

show_filters() {
    echo "=== Built-in Filters ==="
    echo "Shell utilities (standalone): grep, tail, head, awk, sed, cat, tee, sort,"
    echo "  date, sudo, ip, locale, timedatectl, xxd, printf, seq, comm, tr, uniq,"
    echo "  tac, wc, python3, jq, env, ssh, flock, sleep, mktemp"
    echo ""
    echo "Command patterns:"
    echo "  /tmp/tmp.*              - Temp file operations"
    echo "  sh -c ip neigh show     - IP neighbor lookups"
    echo "  ip neigh show           - IP neighbor lookups"
    echo "  ip link show            - Network interface queries"
    echo "  git maintenance run     - Git auto-maintenance"
    echo "  dirname                 - Directory name extraction"
    echo "  openclaw-cmdlog         - This tool's own commands"
    echo "  sessions list --active-minutes  - OpenClaw heartbeat"
    echo "  openclaw.mjs sessions list      - OpenClaw monitoring"
    echo ""
    local repo_config="${SCRIPT_DIR}/filters.conf"
    local user_config="${HOME}/.openclaw/.config/cmdlog.filters.conf"

    # Show repo filters
    if [ -f "$repo_config" ]; then
        echo "=== Repo Filters (${repo_config}) ==="
        local repo_filters
        repo_filters=$(grep -v '^#' "$repo_config" 2>/dev/null | grep -v '^$')
        if [ -n "$repo_filters" ]; then
            echo "$repo_filters" | nl
        else
            echo "  (none configured)"
        fi
    else
        echo "=== Repo Filters ==="
        echo "  (repo filters.conf not found)"
    fi
    echo ""

    # Show user filters
    if [ -f "$user_config" ]; then
        echo "=== User Filters (${user_config}) ==="
        local user_filters
        user_filters=$(grep -v '^#' "$user_config" 2>/dev/null | grep -v '^$')
        if [ -n "$user_filters" ]; then
            echo "$user_filters" | nl
        else
            echo "  (none configured)"
        fi
    else
        echo "=== User Filters ==="
        echo "  (no user config found)"
        echo "  Create ~/.openclaw/.config/cmdlog.filters.conf to add personal filters."
    fi
}

# Process input with awk for speed
# Args: $1 = limit (0 = unlimited), $2 = user_filter_patterns (newline-separated)
process_awk() {
    local limit="${1:-0}"
    local user_filters="${2:-}"
    
    awk -v limit="$limit" -v user_filters="$user_filters" '
    function hex_decode(str) {
        result = ""
        for (i=1; i<=length(str); i+=2) {
            byte = substr(str, i, 2)
            result = result sprintf("%c", strtonum("0x" byte))
        }
        return result
    }
    
    # Check if command matches any user filter pattern
    function matches_user_filter(cmd, filters,    n, i, pattern) {
        n = split(filters, patterns, "\n")
        for (i=1; i<=n; i++) {
            pattern = patterns[i]
            # Trim whitespace
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", pattern)
            if (pattern == "") continue
            if (cmd ~ pattern) return 1
        }
        return 0
    }
    
    BEGIN { count=0; last_ts=""; proctitle_cmd="" }
    
    # Capture PROCTITLE for bash commands with -c
    /type=PROCTITLE/ {
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            last_ts = strftime("%m/%d %H:%M", m[1])
        }
        if (match($0, /proctitle=([0-9a-fA-F]+)/, m)) {
            hex = m[1]
            proc = ""
            for (i=1; i<=length(hex); i+=2) {
                byte = substr(hex, i, 2)
                char = sprintf("%c", strtonum("0x" byte))
                proc = proc char
            }
            if (proc ~ /^bash -c / || proc ~ /^sh -c /) {
                sub(/^bash -c /, "", proc)
                sub(/^sh -c /, "", proc)
                gsub(/[[:cntrl:]]/, "", proc)
                if (proc != "" && proc !~ /^#/) {
                    proctitle_cmd = proc
                }
            }
        }
    }
    
    /type=EXECVE/ {
        if (match($0, /msg=audit\(([0-9]+)/, m)) {
            ts = strftime("%m/%d %H:%M", m[1])
        }
        
        cmd = ""
        for (i=0; i<=5; i++) {
            arg = ""
            pattern_quoted = "a" i "=\"([^\"]+)\""
            pattern_unquoted = "a" i "=([0-9a-fA-F]+)"
            
            if (match($0, pattern_quoted, m)) {
                arg = m[1]
            } else if (match($0, pattern_unquoted, m)) {
                arg = m[1]
            }
            
            if (arg != "") {
                if (arg ~ /^[0-9a-fA-F]+$/ && length(arg) > 4) {
                    arg = hex_decode(arg)
                    if (arg !~ /^[[:print:][:space:]]+$/) arg = ""
                }
                if (i == 0) gsub(/.*\//, "", arg)
                if (arg != "") cmd = (cmd == "" ? arg : cmd " " arg)
            }
        }
        
        # Show PROCTILE decoded builtin
        if ((cmd ~ /^bash / || cmd ~ /^sh /) && proctitle_cmd != "") {
            print last_ts " | [builtin] " proctitle_cmd
            proctitle_cmd = ""
            if (limit > 0 && ++count >= limit) exit
        }
        
        # Built-in filter rules
        first = cmd; sub(/ .*/, "", first)
        
        # User-defined filters
        if (matches_user_filter(cmd, user_filters)) next
        
        if (cmd != "") {
            print ts " | " cmd
            if (limit > 0 && ++count >= limit) exit
        }
    }'
}

# Read and process N lines
cmd_main() {
    local n="${1:-1000}"
    local user_filters
    user_filters=$(load_user_filters)
    echo "Recent commands (last $n):"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | tail -n "$((n*4))" | process_awk "$n" "$user_filters" | tail -n "$n"
}

cmd_all() {
    local user_filters
    user_filters=$(load_user_filters)
    echo "All of today's commands:"
    sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | \
    grep -E "^type=(EXECVE|PROCTITLE)" | process_awk 0 "$user_filters"
}

cmd_recent() { cmd_main "${1:-200}"; }

cmd_search() {
    local pat="${1:-}"
    [ -z "$pat" ] && { echo "Usage: openclaw-cmdlog --search PATTERN"; exit 1; }
    echo "Searching for: $pat"
    cmd_main 1000 | grep -i "$pat"
}

cmd_live() {
    local state_file="${HOME}/.openclaw/.config/cmdlog.seen"
    local user_filters
    user_filters=$(load_user_filters)
    
    # Create state file directory if needed
    mkdir -p "$(dirname "$state_file")"
    
    echo "Watching for new commands... (Ctrl+C to stop)"
    echo "=============================================="
    
    # Seed the seen file with existing commands to avoid replay
    sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
        grep -E "^type=(EXECVE|PROCTITLE)" | process_awk 0 "$user_filters" 2>/dev/null | \
        tee "$state_file" > /dev/null 2>/dev/null || touch "$state_file"
    
    local seen_count=$(wc -l < "$state_file" 2>/dev/null || echo 0)
    echo "Initial state: $seen_count existing commands filtered."
    echo ""
    
    while true; do
        sleep 2
        
        # Query only last 5 seconds (much smaller window)
        sudo ausearch -k clawdbot_exec -ts recent -r 2>/dev/null | \
            grep -E "^type=(EXECVE|PROCTITLE)" | process_awk 0 "$user_filters" 2>/dev/null | \
            while IFS= read -r line; do
                [ -z "$line" ] && continue
                # Check if we've seen this line before
                if ! grep -qxF "$line" "$state_file" 2>/dev/null; then
                    echo "$line"
                    echo "$line" >> "$state_file"
                    # Trim state file to last 1000 lines to prevent unbounded growth
                    tail -n 1000 "$state_file" > "${state_file}.tmp" && mv "${state_file}.tmp" "$state_file" 2>/dev/null || true
                fi
            done
    done
}

cmd_raw() {
    local n="${1:-}"
    if [ -n "$n" ]; then
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep -E "^type=(EXECVE|PROCTITLE)" | tail -n "$n"
    else
        sudo ausearch -k clawdbot_exec -ts today -r 2>/dev/null | grep -E "^type=(EXECVE|PROCTITLE)"
    fi
}

case "${1:-}" in
    --help|-h) show_help ;;
    --all) cmd_all ;;
    --recent) cmd_recent "$2" ;;
    --today) 
        if [ -n "$2" ]; then cmd_main "$2"; else cmd_main 1000; fi
        ;;
    --search) cmd_search "$2" ;;
    --live) cmd_live ;;
    --raw) cmd_raw "$2" ;;
    --show-filters) show_filters ;;
    "") cmd_main 1000 ;;
    [0-9]*) cmd_main "$1" ;;
    *) echo "Unknown option: $1" >&2; exit 1 ;;
esac
